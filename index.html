<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>Tube Bend Calculator — CAD Fillet</title>
<style>
body {
  margin:0;
  font-family:system-ui, Segoe UI, sans-serif;
  background:#0d1117; /* NIEUW zodat je zeker weet dat dit de juiste versie is */
  color:#e5e7eb;
}
.wrapper {
  padding:20px;
  max-width:1400px;
  margin:auto;
}
h2 { margin-top:40px; }
table {
  width:100%;
  border-collapse:collapse;
  margin-top:10px;
}
th, td {
  padding:8px;
  border-bottom:1px solid #333;
}
input, select {
  background:#161b22;
  border:1px solid #333;
  color:white;
  padding:6px;
  border-radius:4px;
}
button {
  background:#238636;
  padding:6px 10px;
  border:none;
  color:white;
  border-radius:4px;
  cursor:pointer;
}
button.del { background:#b62324; }
svg {
  background:#0b0f14;
  width:100%;
  height:550px;
  border:1px solid #222;
  cursor:grab;
}
svg:active { cursor:grabbing; }
.labelbox {
  background:#161b22;
  display:inline-block;
  padding:4px 8px;
  border-radius:6px;
  margin-left:10px;
  border:1px solid #333;
}
</style>
</head>
<body>
<div class="wrapper">

<h1>Tube Bend Calculator — CAD Fillet Engine</h1>

<button id="addSeg">+ Segment</button>
<button id="exportCsv">CSV</button>
<button id="clearAll">Clear</button>

<h2>Segmenten (START→P1, P1→P2, ...)</h2>
<table id="segTable">
<thead>
<tr>
  <th>Segment</th>
  <th>Hoek (°)</th>
  <th>Richting</th>
  <th>Lengte (mm)</th>
  <th>Gain (mm)</th>
  <th>Eff. L (mm)</th>
  <th>Del</th>
</tr>
</thead>
<tbody></tbody>
</table>

<h2>CAD-weergave (zoom + pan)</h2>
<svg id="cad" viewBox="-200 -200 800 800"></svg>

<h2>Productie rechte-view</h2>
<div id="prod"></div>

<h2>Instellingen & Totalen</h2>

<div>
Tube OD:
<select id="od">
  <option value="3/8">3/8"</option>
  <option value="1/2" selected>1/2"</option>
</select>
</div>

<div style="margin-top:10px;">
Radius centerline: <span id="radBox" class="labelbox"></span>
</div>
<div style="margin-top:10px;">
Σ rechte stukken: <span id="sumStraight" class="labelbox"></span>
</div>
<div style="margin-top:10px;">
Σ gains: <span id="sumGains" class="labelbox"></span>
</div>
<div style="margin-top:10px;">
Totaal: <span id="sumTotal" class="labelbox"></span>
</div>

</div>

<script>
// ---------------- CONFIG ----------------
const INCH = 25.4;
const CONFIG = {
  od: {
    "3/8": { R_in: 15/16 },           // 0.9375"
    "1/2": { R_in: 1.5 }              // 1.5"
  },
  gains_in: {
    "3/8": { 45: 1/16, 90: 7/16 },
    "1/2": { 45: 1/16, 90: 11/16 }
  }
};

// ---------------- STATE ----------------
let segs = []; // {ang, dir, len}

// ---------------- HELPERS ----------------
function Rmm() {
  const od = document.getElementById("od").value;
  return CONFIG.od[od].R_in * INCH;
}
function gainMM(ang) {
  const od = document.getElementById("od").value;
  const tbl = CONFIG.gains_in[od];
  return (tbl[ang] || 0) * INCH;
}
function dv(a) { return {x:Math.cos(a), y:Math.sin(a)}; }
function norm(v){ return {x:-v.y, y:v.x}; }

function updateTable() {
  const tb = document.querySelector("#segTable tbody");
  tb.innerHTML="";
  let totalStraight=0;
  let totalGain=0;

  segs.forEach((s,i)=>{
    const tr=document.createElement("tr");
    const gain = gainMM(s.ang);
    totalGain += gain;
    totalStraight += s.len;
    const eff = s.len - gain;

    tr.innerHTML=`
      <td>S${i+1}</td>
      <td><select data-i="${i}" data-f="ang">
             <option>0</option>
             <option>45</option>
             <option>90</option>
           </select>
      </td>
      <td><select data-i="${i}" data-f="dir">
             <option value="">—</option>
             <option value="L">L</option>
             <option value="R">R</option>
           </select>
      </td>
      <td><input type="number" data-i="${i}" data-f="len" min="0" step="0.1" style="width:80px"></td>
      <td>${gain.toFixed(1)}</td>
      <td>${eff.toFixed(1)}</td>
      <td><button class="del" data-del="${i}">X</button></td>
    `;
    tb.appendChild(tr);

    tr.querySelector('[data-f="ang"]').value = s.ang;
    tr.querySelector('[data-f="dir"]').value = s.dir;
    tr.querySelector('[data-f="len"]').value = s.len;
  });

  document.getElementById("sumStraight").textContent = totalStraight.toFixed(1);
  document.getElementById("sumGains").textContent = totalGain.toFixed(1);
  document.getElementById("sumTotal").textContent = (totalStraight-totalGain).toFixed(1);
  document.getElementById("radBox").textContent = Rmm().toFixed(1)+" mm";

  drawCAD();
  drawProduction();
}

// ---------------- CAD DRAW ----------------
function drawCAD(){
  const svg=document.getElementById("cad");
  svg.innerHTML="";

  if(segs.length===0) return;

  let path="";
  let started=false; // Houdt bij of de path is gestart met een M-commando

  let x=0,y=0; // Huidige positie (start bij 0,0)
  let dir=0; // Huidige richting in radialen
  
  const R=Rmm();
  const P=[]; // Lijst van eindpunten P1, P2, ...

  for(let i=0;i<segs.length;i++){
    const s=segs[i];

    // 1. BUIGING (vanaf S2, dus i > 0)
    if(i>0 && s.ang>0 && s.dir){
      const a = s.ang * Math.PI/180;
      const sign = s.dir==="L" ? +1 : -1;
      
      // O is het virtuele buigpunt (x, y) aan het einde van S(i-1)
      const O = {x:x, y:y};
      
      // De geometrische trim afstand (R * tan(a/2))
      const trim = R * Math.tan(a/2); 

      // Richting binnenkomende lijn (S[i-1]'s eindrichting)
      const v_in = dv(dir);
      
      // T1: Einde rechte stuk S(i-1). Stap terug van O langs v_in.
      const T1 = {x:O.x - v_in.x*trim, y:O.y - v_in.y*trim};

      // Ga naar T1 (einde van het rechte deel S(i-1))
      // Omdat i>0 is, is de path al gestart.
      path += ` L ${T1.x} ${T1.y}`;
      
      // Update richting
      dir += sign*a; 
      
      // Richting uitgaande lijn (S[i]'s startrichting)
      const v_out = dv(dir);
      
      // T2: Begin rechte stuk S(i). Stap vooruit van O langs v_out.
      const T2 = {x:O.x + v_out.x*trim, y:O.y + v_out.y*trim};
      
      // Voeg de boog T1 -> T2 toe: A Rx Ry X-rot large-arc-flag sweep-flag x y
      const sweep = (sign<0)?1:0; 
      path += ` A ${R} ${R} 0 0 ${sweep} ${T2.x} ${T2.y}`;

      // Update de huidige positie naar het EINDE van de bocht (T2)
      x = T2.x; 
      y = T2.y; 
    }
    
    // 2. RECHT STUK S(i)
    
    let drawnLength = s.len; 
    
    if(i > 0 && s.ang > 0 && s.dir) {
        // Een bocht heeft plaatsgevonden. Trek de trim-afstand af van de nominale lengte.
        const a = segs[i].ang * Math.PI/180;
        const trim = R * Math.tan(a/2);
        drawnLength = s.len - trim;
    } 
    
    const v=dv(dir);
    const nx=x+v.x*drawnLength;
    const ny=y+v.y*drawnLength;

    if(!started){
        // S1: Start op (0,0) en teken de lijn naar (nx,ny)
        path=`M 0 0 L ${nx} ${ny}`; 
        started=true;
    } else {
        // Voor i>0: L van T2 of vorig P naar (nx,ny)
        path+=` L ${nx} ${ny}`;
    }

    // Update huidige positie naar het einde van segment S(i) (dit is P_i)
    x=nx; y=ny;
    P.push({x,y});
  }

  // draw path
  const p=document.createElementNS("http://www.w3.org/2000/svg","path");
  p.setAttribute("d",path);
  p.setAttribute("stroke","#2f81f7");
  p.setAttribute("stroke-width","2");
  p.setAttribute("fill","none");
  svg.appendChild(p);

  // points
  P.forEach((pt,i)=>{
    const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("cx",pt.x);
    c.setAttribute("cy",pt.y);
    c.setAttribute("r",3);
    c.setAttribute("fill","#0d1117");
    c.setAttribute("stroke","#2f81f7");
    svg.appendChild(c);

    const t=document.createElementNS("http://www.w3.org/2000/svg","text");
    t.textContent=`P${i+1}`;
    t.setAttribute("x",pt.x+6);
    t.setAttribute("y",pt.y-6);
    t.setAttribute("fill","#e5e7eb");
    t.setAttribute("font-size","12");
    svg.appendChild(t);
  });
}

// ---------------- PRODUCTION VIEW ----------------
function drawProduction(){
  const box=document.getElementById("prod");
  box.innerHTML="";
  let html="<h3>Rechte productie-lengtes</h3>";

  segs.forEach((s,i)=>{
    const gain=gainMM(s.ang);
    const eff=s.len-gain;
    html+=`S${i+1}: ${eff.toFixed(1)} mm<br>`;
  });

  box.innerHTML=html;
}

// ---------------- EVENTS ----------------
document.getElementById("addSeg").onclick=function(){
  segs.push({ang:0, dir:"", len:100});
  updateTable();
};
document.getElementById("clearAll").onclick=function(){
  segs=[];
  updateTable();
};
document.getElementById("od").onchange=updateTable;

document.querySelector("#segTable").addEventListener("input",(e)=>{
  const i=e.target.dataset.i;
  const f=e.target.dataset.f;
  if(i!==undefined){
    if(f==="ang") segs[i].ang=Number(e.target.value);
    if(f==="dir") segs[i].dir=e.target.value;
    if(f==="len") segs[i].len=Number(e.target.value);
    updateTable();
  }
});
document.querySelector("#segTable").addEventListener("click",(e)=>{
  if(e.target.dataset.del!==undefined){
    segs.splice(Number(e.target.dataset.del),1);
    updateTable();
  }
});

// Pan + Zoom
(function(){
  const svg=document.getElementById("cad");
  let isDown=false;
  let sx, sy;
  let vx=-200, vy=-200, vw=800;

  svg.addEventListener("mousedown",e=>{
    isDown=true;
    sx=e.clientX;
    sy=e.clientY;
  });
  svg.addEventListener("mousemove",e=>{
    if(!isDown)return;
    const dx=e.clientX-sx;
    const dy=e.clientY-sy;
    vx -= dx*(vw/800);
    vy -= dy*(vw/800);
    svg.setAttribute("viewBox",`${vx} ${vy} ${vw} ${vw}`);
    sx=e.clientX;
    sy=e.clientY;
  });
  svg.addEventListener("mouseup",()=>isDown=false);
  svg.addEventListener("mouseleave",()=>isDown=false);
  svg.addEventListener("wheel",e=>{
    e.preventDefault();
    const factor=1+(e.deltaY>0?0.1:-0.1);
    vw*=factor;
    svg.setAttribute("viewBox",`${vx} ${vy} ${vw} ${vw}`);
  });
})();

// INIT
updateTable();

</script>
</body>
</html>
